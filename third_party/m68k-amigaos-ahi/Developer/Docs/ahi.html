<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>ahi.html</TITLE>
<!-- Source: device.all-c -->
<!-- Generated with RoboDoc v3.0j-lcs (Jan 22 2003) -->
<!-- RoboDoc is copyright 1994-1997 by Maverick Software Development -->
</HEAD><BODY>
<H1 ALIGN="center">TABLE OF CONTENTS</H1>
<OL>
<LI><A HREF="#AHI_AllocAudioA">ahi.device/AHI_AllocAudioA</A>
<LI><A HREF="#AHI_AllocAudioRequestA">ahi.device/AHI_AllocAudioRequestA</A>
<LI><A HREF="#AHI_AudioRequestA">ahi.device/AHI_AudioRequestA</A>
<LI><A HREF="#AHI_BestAudioIDA">ahi.device/AHI_BestAudioIDA</A>
<LI><A HREF="#AHI_ControlAudioA">ahi.device/AHI_ControlAudioA</A>
<LI><A HREF="#AHI_FreeAudio">ahi.device/AHI_FreeAudio</A>
<LI><A HREF="#AHI_FreeAudioRequest">ahi.device/AHI_FreeAudioRequest</A>
<LI><A HREF="#AHI_GetAudioAttrsA">ahi.device/AHI_GetAudioAttrsA</A>
<LI><A HREF="#AHI_LoadSound">ahi.device/AHI_LoadSound</A>
<LI><A HREF="#AHI_NextAudioID">ahi.device/AHI_NextAudioID</A>
<LI><A HREF="#AHI_PlayA">ahi.device/AHI_PlayA</A>
<LI><A HREF="#AHI_SampleFrameSize">ahi.device/AHI_SampleFrameSize</A>
<LI><A HREF="#AHI_UnloadSound">ahi.device/AHI_UnloadSound</A>
<LI><A HREF="#CMD_FLUSH">ahi.device/CMD_FLUSH</A>
<LI><A HREF="#CMD_READ">ahi.device/CMD_READ</A>
<LI><A HREF="#CMD_RESET">ahi.device/CMD_RESET</A>
<LI><A HREF="#CMD_START">ahi.device/CMD_START</A>
<LI><A HREF="#CMD_STOP">ahi.device/CMD_STOP</A>
<LI><A HREF="#CMD_WRITE">ahi.device/CMD_WRITE</A>
<LI><A HREF="#CloseDevice">ahi.device/CloseDevice</A>
<LI><A HREF="#NSCMD_DEVICEQUERY">ahi.device/NSCMD_DEVICEQUERY</A>
<LI><A HREF="#OpenDevice">ahi.device/OpenDevice</A>
</OL>
<HR>

<H2><A NAME="AHI_AllocAudioA">ahi.device/AHI_AllocAudioA</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>AHI_AllocAudioA</B> -- allocates and initializes the audio hardware
       AHI_AllocAudio -- varargs stub for <B>AHI_AllocAudioA</B>()

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       audioctrl = <B>AHI_AllocAudioA</B>( tags );
       D0                           A1

       struct AHIAudioCtrl *<B>AHI_AllocAudioA</B>( struct TagItem * );

       audioctrl = AHI_AllocAudio( tag1, ... );

       struct AHIAudioCtrl *AHI_AllocAudio( Tag, ... );

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Allocates and initializes the audio hardware, selects the best
       mixing routine (if necessary) according to the supplied tags.
       To start playing you first need to call <A HREF="#AHI_ControlAudioA">AHI_ControlAudioA</A>().

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       tags - A pointer to a tag list.

</PRE><FONT SIZE="+1">TAGS</FONT>
<PRE>
       AHIA_AudioID (ULONG) - The audio mode to use. Default is
           AHI_DEFAULT_ID. (AHI_DEFAULT_ID is the ID the user has selected
           in the preferences program. It's a good value to use the first
           time she starts your application.)

       AHIA_MixFreq (ULONG) - Desired mixing frequency. The actual
           mixing rate may or may not be exactly what you asked for.
           Default is AHI_DEFAULT_FREQ. (AHI_DEFAULT_FREQ is the user's
           prefered frequency.)

       AHIA_Channels (UWORD) - Number of channel to use. The actual
           number of channels used will be equal or grater than the
           requested. If too many channels were requested, this function
           will fail. This tag must be supplied.

       AHIA_Sounds (UWORD) - Number of sounds to use. This tag must be
           supplied.

       AHIA_SoundFunc (struct Hook *) - A function to call each time
           when a sound has been started. The function receives the
           following parameters:
               A0 - (struct Hook *)
               A2 - (struct AHIAudioCtrl *)
               A1 - (struct AHISoundMessage *)
           The hook may be called from an interrupt, so normal interrupt
           restrictions apply.

           The called function should follow normal register conventions,
           which means that d2-d7 and a2-a6 must be preserved.

           Default is NULL.

       AHIA_PlayerFunc (struct Hook *) - A function to be called at regular
           intervals. By using this hook there is no need for music players
           to use other timing, such as VBLANK or CIA timers. But the real
           reason it's present is that it makes it possible to do non-
           realtime mixing to disk.

           Using this interrupt source is currently the only supported way
           to ensure that no mixing occurs between calls to AHI_SetVol(),
           AHI_SetFreq() or AHI_SetSound().

           If the sound playback is done without mixing, 'realtime.library'
           is used to provide timing. The function receives the following
           parameters:
               A0 - (struct Hook *)
               A2 - (struct AHIAudioCtrl *)
               A1 - Undefined.
           Do not assume A1 contains any particular value!
           The hook may be called from an interrupt, so normal interrupt
           restrictions apply.

           The called function should follow normal register conventions,
           which means that d2-d7 and a2-a6 must be preserved.

           Default is NULL.

       AHIA_PlayerFreq (Fixed) - If non-zero, enables timing and specifies
           how many times per second PlayerFunc will be called. This must
           be specified if AHIA_PlayerFunc is! Do not use any extreme
           frequencies. The result of MixFreq/PlayerFreq must fit an UWORD,
           ie it must be less or equal to 65535. It is also suggested that
           you keep the result over 80. For normal use this should not be a
           problem. Note that the data type is Fixed, not integer (see BUGS
           below). 50 Hz is 50&lt;&lt;16, which is a reasonable lower limit.

           Default is a reasonable value. Don't depend on it.

       AHIA_MinPlayerFreq (Fixed) - The minimum frequency (AHIA_PlayerFreq)
           you will use. You MUST supply this if you are using the device's
           interrupt feature!

       AHIA_MaxPlayerFreq (Fixed) - The maximum frequency (AHIA_PlayerFreq)
           you will use. You MUST supply this if you are using the device's
           interrupt feature!

       AHIA_RecordFunc (struct Hook *) - This function will be called
           regularly when sampling is turned on (see <A HREF="#AHI_ControlAudioA">AHI_ControlAudioA</A>())
           with the following parameters:
               A0 - (struct Hook *)
               A2 - (struct AHIAudioCtrl *)
               A1 - (struct AHIRecordMessage *)
           The message (AHIRecordMessage) is filled as follows:
               ahirm_Buffer - Pointer to the samples. The buffer is valid
                   until next time the Hook is called.
               ahirm_Length - Number of sample FRAMES in buffer.
                   To get the size in bytes, multiply by 4 if ahiim_Type is
                   AHIST_S16S.
               ahirm_Type - Always AHIST_S16S at the moment, but you *must*
                   check this, since it may change in the future!
           The hook may be called from an interrupt, so normal interrupt
           restrictions apply. Signal a process if you wish to save the
           buffer to disk. The called function should follow normal register
           conventions, which means that d2-d7 and a2-a6 must be preserved.

           NOTE: The function MUST return NULL (in d0). This was previously
           not documented. Now you know.

           Default is NULL.

       AHIA_UserData (APTR) - Can be used to initialize the ahiac_UserData
           field. Default is 0.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>       A pointer to an AHIAudioCtrl structure or NULL if an error occured.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>       SoundFunc will be called in the same manner as Paula interrupts
       occur; when the device has updated its internal variables and can
       accept new commands.

</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>       For compability reasons with some really old applications,
       AHIA_PlayerFreq, AHIA_MinPlayerFreq and AHIA_MaxPlayerFreq 
       interpret values lower than 0x10000 as integers, not Fixed.
       This means that the lowest frequency possible is 1 Hz. However,
       you should *never* use a value than say 10-20 Hz anyway, because
       of the high latency and the impact on multitasking. 

       This kludge will be removed some day. Always use Fixed!


</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       <A HREF="#AHI_FreeAudio">AHI_FreeAudio</A>(), <A HREF="#AHI_ControlAudioA">AHI_ControlAudioA</A>()

</PRE>
<HR>

<H2><A NAME="AHI_AllocAudioRequestA">ahi.device/AHI_AllocAudioRequestA</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>AHI_AllocAudioRequestA</B> -- allocate an audio mode requester.
       AHI_AllocAudioRequest -- varargs stub for <B>AHI_AllocAudioRequestA</B>()

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       requester = <B>AHI_AllocAudioRequestA</B>( tags );
       D0                                  A0

       struct AHIAudioModeRequester *<B>AHI_AllocAudioRequestA</B>(
           struct TagItem * );

       requester = AHI_AllocAudioRequest( tag1, ... );

       struct AHIAudioModeRequester *AHI_AllocAudioRequest( Tag, ... );

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Allocates an audio mode requester data structure.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       tags - A pointer to an optional tag list specifying how to initialize
           the data structure returned by this function. See the
           documentation for <A HREF="#AHI_AudioRequestA">AHI_AudioRequestA</A>() for an explanation of how
           to use the currently defined tags.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>       requester - An initialized requester data structure, or NULL on
           failure. 

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>       The requester data structure is READ-ONLY and can only be modified
       by using tags!

</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>      <A HREF="#AHI_AudioRequestA">AHI_AudioRequestA</A>(), <A HREF="#AHI_FreeAudioRequest">AHI_FreeAudioRequest</A>()

</PRE>
<HR>

<H2><A NAME="AHI_AudioRequestA">ahi.device/AHI_AudioRequestA</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>AHI_AudioRequestA</B> -- get an audio mode from user using an requester.
       AHI_AudioRequest -- varargs stub for <B>AHI_AudioRequestA</B>()

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       success = <B>AHI_AudioRequestA</B>( requester, tags );
       D0                           A0         A1

       BOOL <B>AHI_AudioRequestA</B>( struct AHIAudioModeRequester *,
           struct TagItem * );

       result = AHI_AudioRequest( requester, tag1, ... );

       BOOL AHI_AudioRequest( struct AHIAudioModeRequester *, Tag, ... );

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Prompts the user for an audio mode, based on the modifying tags.
       If the user cancels or the system aborts the request, FALSE is
       returned, otherwise the requester's data structure reflects the
       user input.

       Note that tag values stay in effect for each use of the requester
       until they are cleared or modified by passing the same tag with a
       new value.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       requester - Requester structure allocated with
           <A HREF="#AHI_AllocAudioRequestA">AHI_AllocAudioRequestA</A>(). If this parameter is NULL, this
           function will always return FALSE with a dos.library/IoErr()
           result of ERROR_NO_FREE_STORE.
       tags - Pointer to an optional tag list which may be used to control
           features of the requester.

</PRE><FONT SIZE="+1">TAGS</FONT>
<PRE>       Tags used for the requester (they look remarkable similar to the
       screen mode requester in ASL, don't they? ;-) )

       AHIR_Window (struct Window *) - Parent window of requester. If no
           AHIR_Screen tag is specified, the window structure is used to
           determine on which screen to open the requesting window.

       AHIR_PubScreenName (STRPTR) - Name of a public screen to open on.
           This overrides the screen used by AHIR_Window.

       AHIR_Screen (struct Screen *) - Screen on which to open the
           requester. This overrides the screen used by AHIR_Window or by
           AHIR_PubScreenName.

       AHIR_PrivateIDCMP (BOOL) - When set to TRUE, this tells AHI to
           allocate a new IDCMP port for the requesting window. If not
           specified or set to FALSE, and if AHIR_Window is provided, the
           requesting window will share AHIR_Window's IDCMP port.

       AHIR_IntuiMsgFunc (struct Hook *) - A function to call whenever an
           unknown Intuition message arrives at the message port being used
           by the requesting window. The function receives the following
           parameters:
               A0 - (struct Hook *)
               A1 - (struct IntuiMessage *)
               A2 - (struct AHIAudioModeRequester *)

       AHIR_SleepWindow (BOOL) - When set to TRUE, this tag will cause the
           window specified by AHIR_Window to be "put to sleep". That is, a
           busy pointer will be displayed in the parent window, and no
           gadget or menu activity will be allowed. This is done by opening
           an invisible Intuition Requester in the parent window.

       AHIR_UserData (APTR) - A 32-bit value that is simply copied in the
           ahiam_UserData field of the requester structure.

       AHIR_TextAttr (struct TextAttr *) - Font to be used for the
           requesting window's gadgets and menus. If this tag is not
           provided or its value is NULL, the default font of the screen
           on which the requesting window opens will be used. This font
           must already be in memory as AHI calls OpenFont() and not
           OpenDiskFont().

       AHIR_Locale (struct Locale *) - Locale to use for the requesting
           window. This determines the language used for the requester's
           gadgets and menus. If this tag is not provided or its value is
           NULL, the system's current default locale will be used.

       AHIR_TitleText (STRPTR) - Title to use for the requesting window.
           Default is no title.

       AHIR_PositiveText (STRPTR) - Label of the positive gadget in the
           requester. English default is "OK".

       AHIR_NegativeText (STRPTR) - Label of the negative gadget in the
           requester. English default is "Cancel".

       AHIR_InitialLeftEdge (WORD) - Suggested left edge of requesting
           window.

       AHIR_InitialTopEdge (WORD) - Suggested top edge of requesting
           window.

       AHIR_InitialWidth (WORD) - Suggested width of requesting window.

       AHIR_InitialHeight (WORD) - Suggested height of requesting window.

       AHIR_InitialAudioID (ULONG) - Initial setting of the Mode list view
           gadget (ahiam_AudioID). Default is ~0 (AHI_INVALID_ID), which
           means that no mode will be selected.

       AHIR_InitialMixFreq (ULONG) - Initial setting of the frequency
           slider. Default is the lowest frequency supported.

       AHIR_InitialInfoOpened (BOOL) - Whether to open the property
           information window automatically. Default is FALSE.

       AHIR_InitialInfoLeftEdge (WORD) - Initial left edge of information
           window.

       AHIR_InitialInfoTopEdge (WORD) - Initial top edge of information
           window.

       AHIR_DoMixFreq (BOOL) - Set this tag to TRUE to cause the requester
           to display the frequency slider gadget. Default is FALSE.

       AHIR_DoDefaultMode (BOOL) - Set this tag to TRUE to let the user
           select the mode she has set in the preferences program. If she
           selects this mode,  ahiam_AudioID will be AHI_DEFAULT_ID and
           ahiam_MixFreq will be AHI_DEFAULT_FREQ. Note that if you filter
           the mode list (see below), you must also check the mode (with
           <A HREF="#AHI_BestAudioIDA">AHI_BestAudioIDA</A>()) before you use it since the user may change 
           the meaning of AHI_DEFAULT_MODE anytime, without your knowledge.
           Default is FALSE. (V4)

       AHIR_FilterFunc (struct Hook *) - A function to call for each mode
           encountered. If the function returns TRUE, the mode is included
           in the file list, otherwise it is rejected and not displayed. The
           function receives the following parameters:
               A0 - (struct Hook *)
               A1 - (ULONG) mode id
               A2 - (struct AHIAudioModeRequester *)

       AHIR_FilterTags (struct TagItem *) - A pointer to a tag list used to
           filter modes away, like AHIR_FilterFunc does. The tags are the
           same as <A HREF="#AHI_BestAudioIDA">AHI_BestAudioIDA</A>() takes as arguments. See that function
           for an explanation of each tag.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>       result - FALSE if the user cancelled the requester or if something
           prevented the requester from opening. If TRUE, values in the
           requester structure will be set.

           If the return value is FALSE, you can look at the result from the
           dos.library/IoErr() function to determine whether the requester
           was cancelled or simply failed to open. If dos.library/IoErr()
           returns 0, then the requester was cancelled, any other value
           indicates a failure to open. Current possible failure codes are
           ERROR_NO_FREE_STORE which indicates there was not enough memory,
           and ERROR_NO_MORE_ENTRIES which indicates no modes were available
           (usually because the application filter hook filtered them all
           away).

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>       The requester data structure is READ-ONLY and can only be modified
       by using tags!

       The mixing/recording frequencies that are presented to the user
       may not be the only ones a driver supports, but just a selection.

</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>      <A HREF="#AHI_AllocAudioRequestA">AHI_AllocAudioRequestA</A>(), <A HREF="#AHI_FreeAudioRequest">AHI_FreeAudioRequest</A>()

</PRE>
<HR>

<H2><A NAME="AHI_BestAudioIDA">ahi.device/AHI_BestAudioIDA</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>AHI_BestAudioIDA</B> -- calculate the best ModeID with given parameters
       AHI_BestAudioID -- varargs stub for <B>AHI_BestAudioIDA</B>()

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       ID = <B>AHI_BestAudioIDA</B>( tags );
       D0                     A1

       ULONG <B>AHI_BestAudioIDA</B>( struct TagItem * );

       ID = AHI_BestAudioID( tag1, ... );

       ULONG AHI_BestAudioID( Tag, ... );

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Determines the best AudioID to fit the parameters set in the tag
       list.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       tags - A pointer to a tag list. Only the tags present matter.

</PRE><FONT SIZE="+1">TAGS</FONT>
<PRE>       Many combinations are probably stupid to ask for, like not supporting
       panning or recording.

       AHIDB_AudioID (ULONG) - The mode must use the same audio hardware
           as this mode does.

       AHIDB_Volume (BOOL) - If TRUE: mode must support volume changes.
           If FALSE: mode must not support volume changes.

       AHIDB_Stereo (BOOL) - If TRUE: mode must have stereo output.
           If FALSE: mode must not have stereo output (=mono).

       AHIDB_MultiChannel (BOOL) - If TRUE: mode must have 7.1 channel output.
           If FALSE: mode must not have 7.1 channel output (=mono or stereo).

       AHIDB_Panning (BOOL) - If TRUE: mode must support volume panning.
           If FALSE: mode must not support volume panning. 

       AHIDB_HiFi (BOOL) - If TRUE: mode must have HiFi output.
           If FALSE: mode must not have HiFi output.

       AHIDB_PingPong (BOOL) - If TRUE: mode must support playing samples
           backwards. If FALSE: mode must not support playing samples
           backwards.

       AHIDB_Record (BOOL) - If TRUE: mode must support recording. If FALSE:
           mode must not support recording.

       AHIDB_Realtime (BOOL) - If TRUE: mode must be realtime. If FALSE:
           take a wild guess.

       AHIDB_FullDuplex (BOOL) - If TRUE: mode must be able to record and
           play at the same time.

       AHIDB_Bits (UBYTE) - Mode must have greater or equal number of bits.

       AHIDB_MaxChannels (UWORD) - Mode must have greater or equal number
           of channels.

       AHIDB_MinMixFreq (ULONG) - Lowest mixing frequency supported must be
           less or equal.

       AHIDB_MaxMixFreq (ULONG) - Highest mixing frequency must be greater
           or equal.

       AHIB_Dizzy (struct TagItem *) - This tag points to a second tag list.
           After all other tags has been tested, the mode that matches these
           tags best is returned, i.e. the one that has most of the features
           you ask for, and least of the ones you don't want. Without this
           second tag list, this function hardly does what its name
           suggests. (V4)

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>       ID - The best AudioID to use or AHI_INVALID_ID if none of the modes
           in the audio database could meet the requirements.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>       Due to a bug in the code that compared the boolean tag values in
       version 4.158 and earlier, TRUE must be equal to 1. The bug is not
       present in later revisions.


</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>      <A HREF="#AHI_NextAudioID">AHI_NextAudioID</A>(), <A HREF="#AHI_GetAudioAttrsA">AHI_GetAudioAttrsA</A>()

</PRE>
<HR>

<H2><A NAME="AHI_ControlAudioA">ahi.device/AHI_ControlAudioA</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>AHI_ControlAudioA</B> -- change audio attributes
       AHI_ControlAudio -- varargs stub for <B>AHI_ControlAudioA</B>()

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       error = <B>AHI_ControlAudioA</B>( audioctrl, tags );
       D0                         A2         A1

       ULONG <B>AHI_ControlAudioA</B>( struct AHIAudioCtrl *, struct TagItem * );

       error = AHI_ControlAudio( AudioCtrl, tag1, ...);

       ULONG AHI_ControlAudio( struct AHIAudioCtrl *, Tag, ... );

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       This function should be used to change attributes for a given
       AHIAudioCtrl structure. It is also used to start and stop playback,
       and to control special hardware found on some sound cards.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       audioctrl - A pointer to an AHIAudioCtrl structure.
       tags - A pointer to a tag list.

</PRE><FONT SIZE="+1">TAGS</FONT>
<PRE>       AHIC_Play (BOOL) - Starts (TRUE) and stops (FALSE) playback and
           PlayerFunc. NOTE: If the audio hardware cannot play at the same
           time as recording samples, the recording will be stopped.

       AHIC_Record (BOOL) - Starts (TRUE) and stops (FALSE) sampling and
           RecordFunc. NOTE: If the audio hardware cannot record at the same
           time as playing samples, the playback will be stopped.

       AHIC_MonitorVolume (Fixed) - Sets the input monitor volume, i.e. how
           much of the input signal is mixed with the output signal while
           recording. Use <A HREF="#AHI_GetAudioAttrsA">AHI_GetAudioAttrsA</A>() to find the available range.

       AHIC_MonitorVolume_Query (Fixed *) - Get the current input monitor
           volume. ti_Data is a pointer to a Fixed variable, where the result
           will be stored.

       AHIC_MixFreq_Query (ULONG *) - Get the current mixing frequency.
           ti_Data is a pointer to an ULONG variable, where the result will
           be stored.

       AHIC_InputGain (Fixed) - Set the input gain. Use <A HREF="#AHI_GetAudioAttrsA">AHI_GetAudioAttrsA</A>()
           to find the available range. (V2)

       AHIC_InputGain_Query (Fixed *) - Get current input gain. (V2)

       AHIC_OutputVolume (Fixed) - Set the output volume. Use
           <A HREF="#AHI_GetAudioAttrsA">AHI_GetAudioAttrsA</A>() to find the available range. (V2)

       AHIC_OutputVolume_Query (Fixed *) - Get current output volume. (V2)

       AHIC_Input (ULONG) - Select input source. See <A HREF="#AHI_GetAudioAttrsA">AHI_GetAudioAttrsA</A>().
           (V2)

       AHIC_Input_Query (ULONG *) - Get current input source. (V2)

       AHIC_Output (ULONG) - Select destination for output. See
           <A HREF="#AHI_GetAudioAttrsA">AHI_GetAudioAttrsA</A>(). (V2)

       AHIC_Output_Query (ULONG *) - Get destination for output. (V2)

       The following tags are also recognized by <B>AHI_ControlAudioA</B>(). See
       <A HREF="#AHI_AllocAudioA">AHI_AllocAudioA</A>() for what they do. They may be used from interrupts.

       AHIA_SoundFunc (struct Hook *)
       AHIA_PlayerFunc (struct Hook *)
       AHIA_PlayerFreq (Fixed)
       AHIA_RecordFunc (struct Hook *)
       AHIA_UserData (APTR)

       Note that AHIA_PlayerFreq must never be outside the limits specified
       with AHIA_MinPlayerFreq and AHIA_MaxPlayerFreq! Also note that the
       timing feature is designed to be used for music. When you change the
       frequency, be reasonable. Using 50 Hz one moment and 5 the other is
       to ask for trouble.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>       An error code, defined in &lt;devices/ahi.h&gt;.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>       The AHIC_Play and AHIC_Record tags *must not* be used from
       interrupts.

</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       <A HREF="#AHI_AllocAudioA">AHI_AllocAudioA</A>(), <A HREF="#AHI_GetAudioAttrsA">AHI_GetAudioAttrsA</A>(), &lt;devices/ahi.h&gt;

</PRE>
<HR>

<H2><A NAME="AHI_FreeAudio">ahi.device/AHI_FreeAudio</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>AHI_FreeAudio</B> -- deallocates the audio hardware

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       <B>AHI_FreeAudio</B>( audioctrl );
                      A2

       void <B>AHI_FreeAudio</B>( struct AHIAudioCtrl * );

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Deallocates the AHIAudioCtrl structure and any other resources
       allocated by <A HREF="#AHI_AllocAudioA">AHI_AllocAudioA</A>(). After this call it must not be used
       by any other functions anymore. <A HREF="#AHI_UnloadSound">AHI_UnloadSound</A>() is automatically
       called for every sound.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       audioctrl - A pointer to an AHIAudioCtrl structure obtained from
           <A HREF="#AHI_AllocAudioA">AHI_AllocAudioA</A>(). If NULL, this function does nothing.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       <A HREF="#AHI_AllocAudioA">AHI_AllocAudioA</A>(), <A HREF="#AHI_UnloadSound">AHI_UnloadSound</A>()

</PRE>
<HR>

<H2><A NAME="AHI_FreeAudioRequest">ahi.device/AHI_FreeAudioRequest</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>AHI_FreeAudioRequest</B> -- frees requester resources 

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       <B>AHI_FreeAudioRequest</B>( requester );
                             A0

       void <B>AHI_FreeAudioRequest</B>( struct AHIAudioModeRequester * );

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Frees any resources allocated by <A HREF="#AHI_AllocAudioRequestA">AHI_AllocAudioRequestA</A>(). Once a
       requester has been freed, it can no longer be used with other calls to
       <A HREF="#AHI_AudioRequestA">AHI_AudioRequestA</A>().

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       requester - Requester obtained from <A HREF="#AHI_AllocAudioRequestA">AHI_AllocAudioRequestA</A>(), or NULL
       in which case this function does nothing.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>
</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>      <A HREF="#AHI_AllocAudioRequestA">AHI_AllocAudioRequestA</A>()

</PRE>
<HR>

<H2><A NAME="AHI_GetAudioAttrsA">ahi.device/AHI_GetAudioAttrsA</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>AHI_GetAudioAttrsA</B> -- examine an audio mode via a tag list
       AHI_GetAudioAttrs -- varargs stub for <B>AHI_GetAudioAttrsA</B>()

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       success = <B>AHI_GetAudioAttrsA</B>( ID, [audioctrl], tags );
       D0                            D0  A2           A1

       BOOL <B>AHI_GetAudioAttrsA</B>( ULONG, struct AHIAudioCtrl *,
                                struct TagItem * );

       success = AHI_GetAudioAttrs( ID, [audioctrl], attr1, &amp;result1, ...);

       BOOL AHI_GetAudioAttrs( ULONG, struct AHIAudioCtrl *, Tag, ... );

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Retrieve information about an audio mode specified by ID or audioctrl
       according to the tags in the tag list. For each entry in the tag
       list, ti_Tag identifies the attribute, and ti_Data is mostly a
       pointer to a LONG (4 bytes) variable where you wish the result to be
       stored.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       ID - An audio mode identifier, AHI_DEFAULT_ID (V4) or AHI_INVALID_ID.
       audioctrl - A pointer to an AHIAudioCtrl structure, only used if
           ID equals AHI_INVALID_ID. Set to NULL if not used. If set to
           NULL when used, this function returns immediately. Always set
           ID to AHI_INVALID_ID and use audioctrl if you have allocated
           a valid AHIAudioCtrl structure. Some of the tags return incorrect
           values otherwise.
       tags - A pointer to a tag list.

</PRE><FONT SIZE="+1">TAGS</FONT>
<PRE>       AHIDB_Volume (ULONG *) - TRUE if this mode supports volume changes.

       AHIDB_Stereo (ULONG *) - TRUE if output is in stereo. Unless
           AHIDB_Panning (see below) is TRUE, all even channels are played
           to the left and all odd to the right.

       AHIDB_MultiChannel (ULONG *) - TRUE if output is in 7.1 channels.

       AHIDB_Panning (ULONG *) - TRUE if this mode supports stereo panning.

       AHIDB_HiFi (ULONG *) - TRUE if no shortcuts, like pre-division, is
           used by the mixing routines.

       AHIDB_PingPong (ULONG *) - TRUE if this mode can play samples backwards.

       AHIDB_Record (ULONG *) - TRUE if this mode can record samples.

       AHIDB_FullDuplex (ULONG *) - TRUE if this mode can record and play at
           the same time.

       AHIDB_Realtime (ULONG *) - Modes which return TRUE for this fulfills
           two criteria:
           1) Calls to AHI_SetVol(), AHI_SetFreq() or AHI_SetSound() will be
              performed within (about) 10 ms if called from a PlayFunc Hook.
           2) The PlayFunc Hook will be called at the specified frequency.
           If you don't use AHI's PlayFunc Hook, you must not use modes that
           are not realtime. (Criterium 2 is not that obvious if you consider
           a mode that renders the output to disk as a sample.)

       AHIDB_Bits (ULONG *) - The number of output bits (8, 12, 14, 16 etc).

       AHIDB_MaxChannels (ULONG *) - The maximum number of channels this mode
           can handle.

       AHIDB_MinMixFreq (ULONG *) - The minimum mixing frequency supported.

       AHIDB_MaxMixFreq (ULONG *) - The maximum mixing frequency supported.

       AHIDB_Frequencies (ULONG *) - The number of different sample rates
           available.

       AHIDB_FrequencyArg (ULONG) - Specifies which frequency
           AHIDB_Frequency should return (see below). Range is 0 to
           AHIDB_Frequencies-1 (including).
           NOTE: ti_Data is NOT a pointer, but an ULONG.

       AHIDB_Frequency (ULONG *) - Return the frequency associated with the
           index number specified with AHIDB_FrequencyArg (see above).

       AHIDB_IndexArg (ULONG) - AHIDB_Index will return the index which
           gives the closest frequency to AHIDB_IndexArg
           NOTE: ti_Data is NOT a pointer, but an ULONG.

       AHIDB_Index (ULONG *) - Return the index associated with the frequency
           specified with AHIDB_IndexArg (see above).

       AHIDB_MaxPlaySamples (ULONG *) - Return the lowest number of sample
           frames that must be present in memory when AHIST_DYNAMICSAMPLE
           sounds are used. This number must then be scaled by Fs/Fm, where
           Fs is the frequency of the sound and Fm is the mixing frequency.

       AHIDB_MaxRecordSamples (ULONG *) - Return the number of sample frames
           you will receive each time the RecordFunc is called.

       AHIDB_BufferLen (ULONG) - Specifies how many characters will be
           copied when requesting text attributes. Default is 0, which
           means that AHIDB_Driver, AHIDB_Name, AHIDB_Author,
           AHIDB_Copyright, AHIDB_Version and AHIDB_Annotation,
           AHIDB_Input and AHIDB_Output will do nothing.

       AHIDB_Driver (STRPTR) - Name of driver (excluding path and
           extension). 
           NOTE: ti_Data is a pointer to an UBYTE array where the name
           will be stored. See AHIDB_BufferLen.

       AHIDB_Name (STRPTR) - Human readable name of this mode.
           NOTE: ti_Data is a pointer to an UBYTE array where the name
           will be stored. See AHIDB_BufferLen.

       AHIDB_Author (STRPTR) - Name of driver author.
           NOTE: ti_Data is a pointer to an UBYTE array where the name
           will be stored. See AHIDB_BufferLen.

       AHIDB_Copyright (STRPTR) - Driver copyright notice.
           NOTE: ti_Data is a pointer to an UBYTE array where the name
           will be stored. See AHIDB_BufferLen

       AHIDB_Version (STRPTR) - Driver version string.
           NOTE: ti_Data is a pointer to an UBYTE array where the name
           will be stored. See AHIDB_BufferLen.

       AHIDB_Annotation (STRPTR) - Annotation by driver author.
           NOTE: ti_Data is a pointer to an UBYTE array where the name
           will be stored. See AHIDB_BufferLen.

       AHIDB_MinMonitorVolume (Fixed *)
       AHIDB_MaxMonitorVolume (Fixed *) - Lower/upper limit for input
           monitor volume, see <A HREF="#AHI_ControlAudioA">AHI_ControlAudioA</A>(). If both are 0.0,
           the sound hardware does not have an input monitor feature.
           If both are same, but not 0.0, the hardware always sends the
           recorded sound to the outputs (at the given volume). (V2)

       AHIDB_MinInputGain (Fixed *)
       AHIDB_MaxInputGain (Fixed *) - Lower/upper limit for input gain,
           see <A HREF="#AHI_ControlAudioA">AHI_ControlAudioA</A>(). If both are same, there is no input
           gain hardware. (V2)

       AHIDB_MinOutputVolume (Fixed *)
       AHIDB_MaxOutputVolume (Fixed *) - Lower/upper limit for output
           volume, see <A HREF="#AHI_ControlAudioA">AHI_ControlAudioA</A>(). If both are same, the sound
           card does not have volume control. (V2)

       AHIDB_Inputs (ULONG *) - The number of inputs the sound card has.
           (V2)

       AHIDB_InputArg (ULONG) - Specifies what AHIDB_Input should return
           (see below). Range is 0 to AHIDB_Inputs-1 (including).
           NOTE: ti_Data is NOT a pointer, but an ULONG. (V2)

       AHIDB_Input (STRPTR) - Gives a human readable string describing the
           input associated with the index specified with AHIDB_InputArg
           (see above). See <A HREF="#AHI_ControlAudioA">AHI_ControlAudioA</A>() for how to select one.
           NOTE: ti_Data is a pointer to an UBYTE array where the name
           will be stored. See AHIDB_BufferLen. (V2)

       AHIDB_Outputs (ULONG *) - The number of outputs the sound card
           has. (V2)

       AHIDB_OutputArg (ULONG) - Specifies what AHIDB_Output should return
           (see below). Range is 0 to AHIDB_Outputs-1 (including)
           NOTE: ti_Data is NOT a pointer, but an ULONG. (V2)

       AHIDB_Output (STRPTR) - Gives a human readable string describing the
           output associated with the index specified with AHIDB_OutputArg
           (see above). See <A HREF="#AHI_ControlAudioA">AHI_ControlAudioA</A>() for how to select one.
           NOTE: ti_Data is a pointer to an UBYTE array where the name
           will be stored. See AHIDB_BufferLen. (V2)

       AHIDB_AudioID (ULONG *) - The ID for this mode. (V4)

       If the requested information cannot be found, the variable will be not
       be touched.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>       TRUE if everything went well.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>       In versions earlier than 3, the tags that filled a string buffer would
       not NULL-terminate the string on buffer overflows.

</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>      <A HREF="#AHI_NextAudioID">AHI_NextAudioID</A>(), <A HREF="#AHI_BestAudioIDA">AHI_BestAudioIDA</A>()

</PRE>
<HR>

<H2><A NAME="AHI_LoadSound">ahi.device/AHI_LoadSound</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>AHI_LoadSound</B> -- prepare a sound for playback

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       error = <B>AHI_LoadSound</B>( sound, type, info, audioctrl );
       D0                     D0:16  D1    A0    A2

       ULONG <B>AHI_LoadSound</B>( UWORD, ULONG, APTR, struct AHIAudioCtrl * );

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Defines an ID number for the sound and prepares it for playback.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       sound - The numeric ID to be used as a reference to this sound.
           The ID is a number greater or equal to 0 and less than what you
           specified with AHIA_Sounds when you called <A HREF="#AHI_AllocAudioA">AHI_AllocAudioA</A>().
       type - The type of the sound. Currently four types are supported:
           AHIST_SAMPLE - array of 8 or 16 bit samples. Note that the
               portion of memory where the sample is stored must NOT be
               altered until <A HREF="#AHI_UnloadSound">AHI_UnloadSound</A>() has been called! This is
               because some audio drivers may wish to upload the samples
               to local RAM. It is OK to read, though.

           AHIST_DYNAMICSAMPLE - array of 8 or 16 bit samples, which can be
               updated dynamically. Typically used to play data that is
               loaded from disk or calculated realtime.
               Avoid using this sound type as much as possible; it will
               use much more CPU power than AHIST_SAMPLE on a DMA/DSP
               sound card.

       info - Depends on type:
           AHIST_SAMPLE - A pointer to a struct AHISampleInfo, filled with:
               ahisi_Type - Format of samples (four formats are supported).
                   AHIST_M8S: Mono, 8 bit signed (BYTEs).
                   AHIST_S8S: Stereo, 8 bit signed (2×BYTEs) (V4). 
                   AHIST_M16S: Mono, 16 bit signed (WORDs).
                   AHIST_S16S: Stereo, 16 bit signed (2×WORDs) (V4).
                   AHIST_M32S: Mono, 32 bit signed (LONGs). (V6)
                   AHIST_S32S: Stereo, 32 bit signed (2×LONGs) (V6).
                   AHIST_L7_1: 7.1, 32 bit signed (8×LONGs) (V6).
               ahisi_Address - Address to the sample array.
               ahisi_Length - The size of the array, in samples.
               Don't even think of setting ahisi_Address to 0 and
               ahisi_Length to 0xffffffff as you can do with
               AHIST_DYNAMICSAMPLE! Very few DMA/DSP cards have 4 GB onboard
               RAM...

           AHIST_DYNAMICSAMPLE A pointer to a struct AHISampleInfo, filled
               as described above (AHIST_SAMPLE).
               If ahisi_Address is 0 and ahisi_Length is 0xffffffff
               AHI_SetSound() can take the real address of an 8 bit sample
               to be played as offset argument. Unfortunately, this does not
               work for 16 bit samples.

       audioctrl - A pointer to an AHIAudioCtrl structure.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>       An error code, defined in &lt;devices/ahi.h&gt;.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>       There is no need to place a sample array in Chip memory, but it
       MUST NOT be swapped out! Allocate your sample memory with the
       MEMF_PUBLIC flag set. 

</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>       AHIST_L7_1 can only be played using 7.1 audio modes -- it will NOT
       be downmixed! It can't be played backwards either.

</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       <A HREF="#AHI_UnloadSound">AHI_UnloadSound</A>(), AHI_SetEffect(), AHI_SetFreq(), AHI_SetSound(),
       AHI_SetVol(), &lt;devices/ahi.h&gt;

</PRE>
<HR>

<H2><A NAME="AHI_NextAudioID">ahi.device/AHI_NextAudioID</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>AHI_NextAudioID</B> -- iterate current audio mode identifiers

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       next_ID = <B>AHI_NextAudioID</B>( last_ID );
       D0                         D0

       ULONG <B>AHI_NextAudioID</B>( ULONG );

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       This function is used to iterate through all current AudioIDs in
       the audio database.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       last_ID - previous AudioID or AHI_INVALID_ID if beginning iteration.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>       next_ID - subsequent AudioID or AHI_INVALID_ID if no more IDs.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>      <A HREF="#AHI_GetAudioAttrsA">AHI_GetAudioAttrsA</A>(), <A HREF="#AHI_BestAudioIDA">AHI_BestAudioIDA</A>()

</PRE>
<HR>

<H2><A NAME="AHI_PlayA">ahi.device/AHI_PlayA</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>AHI_PlayA</B> -- Start multiple sounds in one call (V4)
       AHI_Play -- varargs stub for <B>AHI_PlayA</B>()

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       <B>AHI_PlayA</B>( audioctrl, tags );
                  A2         A1

       void <B>AHI_PlayA</B>( struct AHIAudioCtrl *, struct TagItem * );

       AHI_Play( AudioCtrl, tag1, ...);

       void AHI_Play( struct AHIAudioCtrl *, Tag, ... );

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       This function performs the same actions as multiple calls to
       AHI_SetFreq(), AHI_SetSound() and AHI_SetVol(). The advantages
       of using only one call is that simple loops can be set without
       using a SoundFunc (see <A HREF="#AHI_AllocAudioA">AHI_AllocAudioA</A>(), tag AHIA_SoundFunc) and
       that sounds on different channels can be synchronized even when the
       sounds are not started from a PlayerFunc (see <A HREF="#AHI_AllocAudioA">AHI_AllocAudioA</A>(), tag
       AHIA_PlayerFunc). The disadvantage is that this call has more
       overhead than AHI_SetFreq(), AHI_SetSound() and AHI_SetVol(). It is
       therefore recommended that you only use this call if you are not
       calling from a SoundFunc or PlayerFunc.

       The supplied tag list works like a 'program'. This means that
       the order of tags matter.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       audioctrl - A pointer to an AHIAudioCtrl structure.
       tags - A pointer to a tag list.

</PRE><FONT SIZE="+1">TAGS</FONT>
<PRE>       AHIP_BeginChannel (UWORD) - Before you start setting attributes
           for a sound to play, you have to use this tag to chose a
           channel to operate on. If AHIP_BeginChannel is omitted, the
           result is undefined.

       AHIP_EndChannel (ULONG) - Signals the end of attributes for
           the current channel. If AHIP_EndChannel is omitted, the result
           is undefined. ti_Data MUST BE NULL!

       AHIP_Freq (ULONG) - The playback frequency in Hertz or AHI_MIXFREQ.

       AHIP_Vol (Fixed) - The desired volume. If omitted, but AHIP_Pan is
           present, AHIP_Vol defaults to 0.

       AHIP_Pan (sposition) - The desired panning. If omitted, but AHIP_Vol
           is present, AHIP_Pan defaults to 0 (extreme left).

       AHIP_Sound (UWORD) - Sound to be played, or AHI_NOSOUND.

       AHIP_Offset (ULONG) - Specifies an offset (in samples) into the
           sound. If this tag is present, AHIP_Length MUST be present too!

       AHIP_Length (LONG) - Specifies how many samples that should be
           played.

       AHIP_LoopFreq (ULONG)
       AHIP_LoopVol (Fixed)
       AHIP_LoopPan (sposition)
       AHIP_LoopSound (UWORD)
       AHIP_LoopOffset (ULONG)
       AHIP_LoopLength (LONG) - These tags can be used to set simple loop
          attributes. They default to their sisters. These tags must be
          after the other tags.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>
</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       AHI_SetFreq(), AHI_SetSound(), AHI_SetVol()

</PRE>
<HR>

<H2><A NAME="AHI_SampleFrameSize">ahi.device/AHI_SampleFrameSize</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>AHI_SampleFrameSize</B> -- get the size of a sample frame (V4)

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       size = <B>AHI_SampleFrameSize</B>( sampletype );
       D0                          D0

       ULONG <B>AHI_SampleFrameSize</B>( ULONG );

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Returns the size in bytes of a sample frame for a given sample type.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       sampletype - The sample type to examine. See &lt;devices/ahi.h&gt; for
           possible types.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>       The number of bytes, or 0 for invalid types.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>       This function returned trash for invalid sample types
       before V6.

</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>      &lt;devices/ahi.h&gt;

</PRE>
<HR>

<H2><A NAME="AHI_UnloadSound">ahi.device/AHI_UnloadSound</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>AHI_UnloadSound</B> -- discard a sound

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       <B>AHI_UnloadSound</B>( sound, audioctrl );
                        D0:16  A2

       void <B>AHI_UnloadSound</B>( UWORD, struct AHIAudioCtrl * );

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Tells 'ahi.device' that this sound will not be used anymore.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       sound - The ID of the sound to unload.
       audioctrl - A pointer to an AHIAudioCtrl structure.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>
</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>       This call will not break a Forbid() state.

</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       <A HREF="#AHI_LoadSound">AHI_LoadSound</A>()

</PRE>
<HR>

<H2><A NAME="CMD_FLUSH">ahi.device/CMD_FLUSH</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>CMD_FLUSH</B> -- Cancel all I/O requests (V4)

</EM></PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Aborts ALL current requests, both active and waiting, even
       other programs requests!

</PRE><FONT SIZE="+1">IO REQUEST INPUT</FONT>
<PRE>       io_Device       Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Unit         Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Command      <B>CMD_FLUSH</B>

</PRE><FONT SIZE="+1">IO REQUEST RESULT</FONT>
<PRE>       io_Error        0 for success, or an error code as defined in
                       &lt;ahi/devices.h&gt; and &lt;exec/errors.h&gt;.
       io_Actual       If io_Error is 0, number of requests actually
                       flushed.

       The other fields, except io_Device, io_Unit and io_Command, are
       trashed.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>       This command should only be used in very rare cases, like AHI
       system utilities. Never use this command in an application.

</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       <A HREF="#CMD_RESET">CMD_RESET</A>, &lt;ahi/devices.h&gt;, &lt;exec/errors.h&gt;

</PRE>
<HR>

<H2><A NAME="CMD_READ">ahi.device/CMD_READ</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>CMD_READ</B> -- Read raw samples from audio input (V4)

</EM></PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Reads samples from the users prefered input to memory. The sample
       format and frequency will be converted on the fly. 

</PRE><FONT SIZE="+1">IO REQUEST INPUT</FONT>
<PRE>       io_Device       Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Unit         Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Command      <B>CMD_READ</B>
       io_Data         Pointer to the buffer where the data should be put.
       io_Length       Number of bytes to read, must be a multiple of the
                       sample frame size (see ahir_Type).
       io_Offset       Set to 0 when you use for the first time or after
                       a delay.
       ahir_Type       The desired sample format, see &lt;ahi/devices.h&gt;.
       ahir_Frequency  The desired sample frequency in Hertz.

</PRE><FONT SIZE="+1">IO REQUEST RESULT</FONT>
<PRE>       io_Error        0 for success, or an error code as defined in
                       &lt;ahi/devices.h&gt; and &lt;exec/errors.h&gt;.
       io_Actual       If io_Error is 0, number of bytes actually
                       transferred. Starting with V6, io_Actual is also
                       valid if io_Error is not 0 (like if the request
                       was aborted).
       io_Offset       Updated to be used as input next time.

       The other fields, except io_Device, io_Unit and io_Command, are
       trashed.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>       It's only possible to read signed mono or stereo samples.

</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       &lt;ahi/devices.h&gt;, &lt;exec/errors.h&gt;

</PRE>
<HR>

<H2><A NAME="CMD_RESET">ahi.device/CMD_RESET</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>CMD_RESET</B> -- Restore device to a known state (V4)

</EM></PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Aborts all current requests, even other programs requests
       (<A HREF="#CMD_FLUSH">CMD_FLUSH</A>), rereads the configuration file and resets the hardware
       to its initial state
       

</PRE><FONT SIZE="+1">IO REQUEST INPUT</FONT>
<PRE>       io_Device       Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Unit         Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Command      <B>CMD_RESET</B>

</PRE><FONT SIZE="+1">IO REQUEST RESULT</FONT>
<PRE>       io_Error        0 for success, or an error code as defined in
                       &lt;ahi/devices.h&gt; and &lt;exec/errors.h&gt;.

       The other fields, except io_Device, io_Unit and io_Command, are
       trashed.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>       This command should only be used in very rare cases, like AHI
       system utilities. Never use this command in an application.

</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       <A HREF="#CMD_FLUSH">CMD_FLUSH</A>, &lt;ahi/devices.h&gt;, &lt;exec/errors.h&gt;

</PRE>
<HR>

<H2><A NAME="CMD_START">ahi.device/CMD_START</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>CMD_START</B> -- start device processing (like ^Q) (V4)

</EM></PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       All <A HREF="#CMD_WRITE">CMD_WRITE</A>'s that has been sent to the device since <A HREF="#CMD_STOP">CMD_STOP</A>
       will be started at once, synchronized.

</PRE><FONT SIZE="+1">IO REQUEST INPUT</FONT>
<PRE>       io_Device       Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Unit         Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Command      <B>CMD_START</B>

</PRE><FONT SIZE="+1">IO REQUEST RESULT</FONT>
<PRE>       io_Error        0 for success, or an error code as defined in
                       &lt;ahi/devices.h&gt; and &lt;exec/errors.h&gt;.

       The other fields, except io_Device, io_Unit and io_Command, are
       trashed.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>       Unlike most (all?) other devices, <A HREF="#CMD_STOP">CMD_STOP</A> and <B>CMD_START</B> do nest in
       ahi.device.

</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       <A HREF="#CMD_STOP">CMD_STOP</A>, &lt;ahi/devices.h&gt;, &lt;exec/errors.h&gt;

</PRE>
<HR>

<H2><A NAME="CMD_STOP">ahi.device/CMD_STOP</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>CMD_STOP</B> -- stop device processing (like ^S) (V4)

</EM></PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Stops all <A HREF="#CMD_WRITE">CMD_WRITE</A> processing. All writes will be queued, and
       are not processed until <A HREF="#CMD_START">CMD_START</A>. This is useful for synchronizing
       two or more <A HREF="#CMD_WRITE">CMD_WRITE</A>'s.

</PRE><FONT SIZE="+1">IO REQUEST INPUT</FONT>
<PRE>       io_Device       Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Unit         Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Command      <B>CMD_STOP</B>

</PRE><FONT SIZE="+1">IO REQUEST RESULT</FONT>
<PRE>       io_Error        0 for success, or an error code as defined in
                       &lt;ahi/devices.h&gt; and &lt;exec/errors.h&gt;.

       The other fields, except io_Device, io_Unit and io_Command, are
       trashed.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>       This command affects ALL writes, even those sent by other
       applications. Make sure the code between <B>CMD_STOP</B> and <A HREF="#CMD_START">CMD_START</A>
       runs as fast as possible!

       Unlike most (all?) other devices, <B>CMD_STOP</B> and <A HREF="#CMD_START">CMD_START</A> do nest in
       ahi.device.

</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       <A HREF="#CMD_START">CMD_START</A>, &lt;ahi/devices.h&gt;, &lt;exec/errors.h&gt;

</PRE>
<HR>

<H2><A NAME="CMD_WRITE">ahi.device/CMD_WRITE</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>CMD_WRITE</B> -- Write raw samples to audio output (V4)

</EM></PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Plays the samples to the users prefered audio output.

</PRE><FONT SIZE="+1">IO REQUEST INPUT</FONT>
<PRE>       io_Device       Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Unit         Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Command      <B>CMD_WRITE</B>
       io_Data         Pointer to the buffer of samples to be played.
       io_Length       Number of bytes to play, must be a multiple of the
                       sample frame size (see ahir_Type).
       io_Offset       Must be 0.
       ahir_Type       The desired sample format, see &lt;ahi/devices.h&gt;.
       ahir_Frequency  The desired sample frequency in Hertz.
       ahir_Volume     The desired volume. The range is 0 to 0x10000, where
                       0 means muted and 0x10000 (== 1.0) means full volume.
       ahir_Position   Defines the stereo balance. 0 is far left, 0x8000 is
                       center and 0x10000 is far right.
       ahir_Link       If non-zero, pointer to a previously sent AHIRequest
                       which this AHIRequest will be linked to. This
                       request will be delayed until the old one is
                       finished (used for double buffering). Must be set
                       to NULL if not used.

</PRE><FONT SIZE="+1">IO REQUEST RESULT</FONT>
<PRE>       io_Error        0 for success, or an error code as defined in
                       &lt;ahi/devices.h&gt; and &lt;exec/errors.h&gt;.
       io_Actual       If io_Error is 0, number of bytes actually
                       played. Starting with V6, io_Actual is also valid
                       if io_Error is not 0 (like if the request was
                       aborted).

       The other fields, except io_Device, io_Unit and io_Command, are
       trashed.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>       32 bit samples (ahir_Type) is only available in V6 and later.

</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       &lt;ahi/devices.h&gt;, &lt;exec/errors.h&gt;

</PRE>
<HR>

<H2><A NAME="CloseDevice">ahi.device/CloseDevice</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>CloseDevice</B> -- Close the device

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       <B>CloseDevice</B>(ioRequest)
                   A1

       void <B>CloseDevice</B>(struct IORequest *);

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       This is an exec call that closes the device. Every <A HREF="#OpenDevice">OpenDevice</A>()
       must be matched with a call to <B>CloseDevice</B>().

       The user must ensure that all outstanding IO Requests have been
       returned before closing the device.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       ioRequest - a pointer to the same struct AHIRequest that was used
           to open the device.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>
</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>      <A HREF="#OpenDevice">OpenDevice</A>(), exec.library/<B>CloseDevice</B>()

</PRE>
<HR>

<H2><A NAME="NSCMD_DEVICEQUERY">ahi.device/NSCMD_DEVICEQUERY</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>NSCMD_DEVICEQUERY</B> -- Query the device for its capabilities (V4)

</EM></PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Fills an initialized NSDeviceQueryResult structure with
       information about the device.

</PRE><FONT SIZE="+1">IO REQUEST INPUT</FONT>
<PRE>       io_Device       Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Unit         Preset by the call to <A HREF="#OpenDevice">OpenDevice</A>().
       io_Command      <B>NSCMD_DEVICEQUERY</B>
       io_Data         Pointer to the NSDeviceQueryResult structure,
                       initialized as follows:
                           DevQueryFormat - Set to 0
                           SizeAvailable  - Must be cleared.
                       It is probably good manners to clear all other
                       fields as well.
       io_Length       Size of the NSDeviceQueryResult structure.

</PRE><FONT SIZE="+1">IO REQUEST RESULT</FONT>
<PRE>       io_Error        0 for success, or an error code as defined in
                       &lt;ahi/devices.h&gt; and &lt;exec/errors.h&gt;.
       io_Actual       If io_Error is 0, the value in
                       NSDeviceQueryResult.SizeAvailable.

       The NSDeviceQueryResult structure now contains valid information.

       The other fields, except io_Device, io_Unit and io_Command, are
       trashed.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       &lt;ahi/devices.h&gt;, &lt;exec/errors.h&gt;

</PRE>
<HR>

<H2><A NAME="OpenDevice">ahi.device/OpenDevice</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE><EM>       <B>OpenDevice</B> -- Open the device

</EM></PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       error = <B>OpenDevice</B>(AHINAME, unit, ioRequest, flags)
       D0                 A0       D0    A1         D1

       BYTE <B>OpenDevice</B>(STRPTR, ULONG, struct AHIRequest *, ULONG);

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       This is an exec call.  Exec will search for the ahi.device, and
       if found, will pass this call on to the device.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       AHINAME - pointer to the string "ahi.device".
       unit - Either AHI_DEFAULT_UNIT (0), AHI_NO_UNIT (255) or any other
           unit the user has requested, for example with a UNIT tooltype.
           AHI_NO_UNIT should be used when you're using the low-level
           API.
       ioRequest - a pointer to a struct AHIRequest, initialized by
           exec.library/CreateIORequest(). ahir_Version *must* be preset
           to the version you need!
       flags - There is only one flag defined, AHIDF_NOMODESCAN, which
           asks ahi.device not to build the audio mode database if not
           already initialized. It should not be used by applications
           without good reasons (AddAudioModes uses this flag).

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>       error - Same as io_Error.
       io_Error - If the call succeeded, io_Error will be 0, else
           an error code as defined in &lt;exec/errors.h&gt; and
           &lt;devices/ahi.h&gt;.
       io_Device - A pointer to the device base, which can be used
           to call the functions the device provides.

</PRE><FONT SIZE="+1">EXAMPLE</FONT>
<PRE>
</PRE><FONT SIZE="+1">NOTES</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">BUGS</FONT>
<PRE><EM>
</EM></PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>      <A HREF="#CloseDevice">CloseDevice</A>(), exec.library/<B>OpenDevice</B>(), &lt;exec/errors.h&gt;,
      &lt;devices/ahi.h&gt;.

</PRE>
</BODY></HTML>
